//State（normal）
//「状態」をクラスとして表現して、状態の変化に応じて振る舞いが変わるようにする
//例えば、「機嫌のいい状態」「機嫌が悪い状態」の2つの状態があるお母さんに頼みごとをする
//機嫌のいい状態のお母さんにお願いをすると、お願いを聞いてくれる
//逆に、機嫌の悪い状態のお母さんにお願いをしても聞き入れてくれないかもしれない
//というように、お母さんは状態によって、振る舞いが変わる

//Stateパターンの構造は、Strategyパターンと似ているが、目的が異なる
//Strategyパターンは、アルゴリズムの切り替えを行うので、基本的にそれぞれの戦略クラスが
//していることは同じ。
//例えば、どの戦略クラスを使うとしても、していることが「ソート」であることに変わらないなど
//Strategyパターンの場合は、それほど頻繁に切り替えが発生しないことが多い

//Stateパターンは、今の「状態」に応じてそれぞれがしていることは異なる
//例えば、「朝にだけ朝礼」、「夜にだけその日の売上集計」など

//Stateパターンを使わない場合、状態に応じた分岐構造（多分岐構造）が必要になる
/*
switch(mTime){
	case TIME_MORNING:
		break;
	case TIME_DAY:
		break;
	case TIME_NIGHT:
		break;
};
*/
//問題なのは、新たな状態が必要になったとき、このように分岐している箇所を探し出し、
//それぞれに新たな条件を追加しなければならなくなる

//【プログラム】朝、日中、夜の時間帯で、行動が異なることを表す
//それぞれの状態に応じた共通interfaceを定義し、それぞれの状態クラスを定義する
//そして、状況に応じて状態オブジェクトを振舞わせる
//
//State00(normal).cpp
//結果
//洗濯炊事
//仕事ガンガン
//趣味で歌って踊る

#include <iostream>
#include <string>
using namespace std;

//Sate定義----------------------------------------------------------
//////////////////////////////////////////////////////////////////
//時間帯interfaceクラス定義（抽象クラス）
class TimeState {
public:
	virtual void request() = 0;			//何か処理を要求する
};

//////////////////////////////////////////////////////////////////
//時間帯が朝クラス定義
class TimeMorning : public TimeState {
public:
	void request(){ cout << "洗濯炊事" << endl; }
};
//----------------------------------------------------------------
//時間帯が昼クラス定義
class TimeDay : public TimeState {
public:
	void request(){ cout << "仕事ガンガン" << endl; }
};
//----------------------------------------------------------------
//時間帯が夜クラス定義
class TimeNight : public TimeState {
public:
	void request(){ cout << "趣味で歌って踊る" << endl; }
};
//----------------------------------------------------------------------

///////////////////////////////////////////////////////////////////
int main()
{
	TimeState* timeP;
	
	//朝
	timeP = new TimeMorning();
	timeP->request();
	
	//昼に変更
	delete timeP;
	timeP = new TimeDay();
	timeP->request();
	
	//夜に変更
	delete timeP;
	timeP = new TimeNight();
	timeP->request();
	
	delete timeP;

	return 0;
}
